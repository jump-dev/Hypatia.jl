var documenterSearchIndex = {"docs":
[{"location":"api/cones/#Cones-module","page":"Cones module","title":"Cones module","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"See the Cone interface and predefined cones section.","category":"page"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"CurrentModule = Hypatia.Cones","category":"page"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"Cones\nCone","category":"page"},{"location":"api/cones/#Hypatia.Cones","page":"Cones module","title":"Hypatia.Cones","text":"Proper cone definitions, oracles, and utilities.\n\n\n\n\n\n","category":"module"},{"location":"api/cones/#Hypatia.Cones.Cone","page":"Cones module","title":"Hypatia.Cones.Cone","text":"abstract type Cone{T<:Real}\n\nA proper cone.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Array-utilities","page":"Cones module","title":"Array utilities","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"vec_length\nvec_copyto!\nsvec_length\nsvec_side\nsvec_idx\nblock_idxs\nscale_svec!\nsmat_to_svec!\nsvec_to_smat!","category":"page"},{"location":"api/cones/#Hypatia.Cones.vec_length","page":"Cones module","title":"Hypatia.Cones.vec_length","text":"vec_length(_, len)\n\n\nThe dimension of the real vectorization of a real or complex vector of length len::Int.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.vec_copyto!","page":"Cones module","title":"Hypatia.Cones.vec_copyto!","text":"vec_copyto!(v1, v2)\n\n\nCopy a vector in-place.\n\n\n\n\n\nvec_copyto!(rvec, cvec)\n\n\nCopy a complex vector to a real vector in-place.\n\n\n\n\n\nvec_copyto!(cvec, rvec)\n\n\nCopy a real vector to a complex vector in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.svec_length","page":"Cones module","title":"Hypatia.Cones.svec_length","text":"svec_length(side)\n\n\nThe dimension of the vectorized triangle of a real symmetric matrix with side dimension side::Int.\n\n\n\n\n\nsvec_length(_, side)\n\n\nThe dimension of the real vectorized triangle of a real symmetric or complex Hermitian matrix with side dimension side::Int.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.svec_side","page":"Cones module","title":"Hypatia.Cones.svec_side","text":"svec_side(len)\n\n\nThe side dimension of a real symmetric matrix with vectorized triangle length len::Int.\n\n\n\n\n\nsvec_side(_, len)\n\n\nThe side dimension of a real symmetric or complex Hermitian matrix with real vectorized triangle length  len::Int.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.svec_idx","page":"Cones module","title":"Hypatia.Cones.svec_idx","text":"svec_idx(row, col)\n\n\nThe index in the vectorized triangle of a symmetric matrix for element (row::Int, col::Int).\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.block_idxs","page":"Cones module","title":"Hypatia.Cones.block_idxs","text":"block_idxs(incr, block)\n\n\nThe indices corresponding to block block::Int in a vector of blocks with equal length incr::Int.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.scale_svec!","page":"Cones module","title":"Hypatia.Cones.scale_svec!","text":"scale_svec!(arr, scal; incr)\n\n\nRescale the elements corresponding to off-diagonals in arr::AbstractVecOrMat, with scaling scal::Real and default block increment incr::Int = 1.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.smat_to_svec!","page":"Cones module","title":"Hypatia.Cones.smat_to_svec!","text":"smat_to_svec!(vec, mat, rt2)\n\n\nCopy a real symmetric matrix upper triangle to a svec-scaled vector in-place.\n\n\n\n\n\nsmat_to_svec!(vec, mat, rt2)\n\n\nCopy a complex Hermitian matrix upper triangle to a svec-scaled real vector in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.svec_to_smat!","page":"Cones module","title":"Hypatia.Cones.svec_to_smat!","text":"svec_to_smat!(mat, vec, rt2)\n\n\nCopy a svec-scaled vector to a real symmetric matrix upper triangle in-place.\n\n\n\n\n\nsvec_to_smat!(mat, vec, rt2)\n\n\nCopy a svec-scaled real vector to a complex Hermitian matrix upper triangle in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Cone-oracles","page":"Cones module","title":"Cone oracles","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"dimension\nget_nu\nset_initial_point!\nis_feas\nis_dual_feas\ngrad\nhess\ninv_hess\nhess_prod!\ninv_hess_prod!\nuse_dder3\ndder3","category":"page"},{"location":"api/cones/#Hypatia.Cones.dimension","page":"Cones module","title":"Hypatia.Cones.dimension","text":"dimension(cone)\n\n\nThe real vector dimension of the cone.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.get_nu","page":"Cones module","title":"Hypatia.Cones.get_nu","text":"get_nu(cone)\n\n\nThe barrier parameter nu of the cone.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.set_initial_point!","page":"Cones module","title":"Hypatia.Cones.set_initial_point!","text":"set_initial_point!(arr, cone)\n\n\nSet the array equal to the initial interior point for the cone.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.is_feas","page":"Cones module","title":"Hypatia.Cones.is_feas","text":"is_feas(cone)\n\n\nReturns true if and only if the currently-loaded primal point is strictly feasible for the cone.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.is_dual_feas","page":"Cones module","title":"Hypatia.Cones.is_dual_feas","text":"is_dual_feas(cone)\n\n\nReturns false only if the currently-loaded dual point is outside the interior of the cone's dual cone.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.grad","page":"Cones module","title":"Hypatia.Cones.grad","text":"grad(cone)\n\n\nThe gradient of the cone's barrier function at the currently-loaded primal point.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.hess","page":"Cones module","title":"Hypatia.Cones.hess","text":"hess(cone)\n\n\nThe Hessian (symmetric positive definite) of the cone's barrier function at the currently-loaded primal point.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.inv_hess","page":"Cones module","title":"Hypatia.Cones.inv_hess","text":"inv_hess(cone)\n\n\nThe inverse Hessian (symmetric positive definite) of the cone's barrier function at the currently-loaded primal point.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.hess_prod!","page":"Cones module","title":"Hypatia.Cones.hess_prod!","text":"hess_prod!(prod, arr, cone)\n\n\nCompute the product of the Hessian of the cone's barrier function at the currently-loaded primal point with a vector or array, in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.inv_hess_prod!","page":"Cones module","title":"Hypatia.Cones.inv_hess_prod!","text":"inv_hess_prod!(prod, arr, cone)\n\n\nCompute the product of the inverse Hessian of the cone's barrier function at the currently-loaded primal point with a vector or array, in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.use_dder3","page":"Cones module","title":"Hypatia.Cones.use_dder3","text":"use_dder3(_)\n\n\nReturns true if and only if the oracle for the third-order directional derivative oracle dder3 can be computed.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.dder3","page":"Cones module","title":"Hypatia.Cones.dder3","text":"dder3(cone, dir)\n\n\nCompute the third-order directional derivative, in the direction dir, the cone's barrier function at the currently-loaded primal point.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Predefined-cone-types","page":"Cones module","title":"Predefined cone types","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"Nonnegative\nPosSemidefTri\nDoublyNonnegativeTri\nPosSemidefTriSparse\nLinMatrixIneq\nEpiNormInf\nEpiNormEucl\nEpiPerSquare\nEpiNormSpectral\nMatrixEpiPerSquare\nGeneralizedPower\nHypoPowerMean\nHypoGeoMean\nHypoRootdetTri\nHypoPerLog\nHypoPerLogdetTri\nEpiPerSepSpectral\nEpiRelEntropy\nEpiTrRelEntropyTri\nWSOSInterpNonnegative\nWSOSInterpPosSemidefTri\nWSOSInterpEpiNormEucl\nWSOSInterpEpiNormOne","category":"page"},{"location":"api/cones/#Hypatia.Cones.Nonnegative","page":"Cones module","title":"Hypatia.Cones.Nonnegative","text":"mutable struct Nonnegative{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nNonnegative cone of dimension dim.\n\nNonnegative{T}(dim::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.PosSemidefTri","page":"Cones module","title":"Hypatia.Cones.PosSemidefTri","text":"mutable struct PosSemidefTri{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nReal symmetric or complex Hermitian positive semidefinite cone of dimension dim in svec format.\n\nPosSemidefTri{T, R}(dim::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.DoublyNonnegativeTri","page":"Cones module","title":"Hypatia.Cones.DoublyNonnegativeTri","text":"mutable struct DoublyNonnegativeTri{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nReal symmetric doubly nonnegative cone (intersection of nonnegative and positive semidefinite cones) of dimension dim in svec format.\n\nDoublyNonnegativeTri{T}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.PosSemidefTriSparse","page":"Cones module","title":"Hypatia.Cones.PosSemidefTriSparse","text":"mutable struct PosSemidefTriSparse{I<:Hypatia.Cones.PSDSparseImpl, T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nReal symmetric or complex Hermitian sparse positive semidefinite cone of side dimension side and sparse lower triangle row and column indices rows, cols in svec format. Note all diagonal elements must be present.\n\nPosSemidefTriSparse{T, R}(side::Int, rows::Vector{Int}, cols::Vector{Int}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.LinMatrixIneq","page":"Cones module","title":"Hypatia.Cones.LinMatrixIneq","text":"mutable struct LinMatrixIneq{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nLinear matrix inequality cone parametrized by list of real symmetric or complex Hermitian matrices mats of equal dimension.\n\nLinMatrixIneq{T}(mats::Vector, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiNormInf","page":"Cones module","title":"Hypatia.Cones.EpiNormInf","text":"mutable struct EpiNormInf{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of real or complex infinity norm cone of dimension dim.\n\nEpiNormInf{T, R}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiNormEucl","page":"Cones module","title":"Hypatia.Cones.EpiNormEucl","text":"mutable struct EpiNormEucl{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of Euclidean norm (AKA second-order) cone of dimension dim.\n\nEpiNormEucl{T}(dim::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiPerSquare","page":"Cones module","title":"Hypatia.Cones.EpiPerSquare","text":"mutable struct EpiPerSquare{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of perspective function of halved squared Euclidean norm (AKA rotated second-order) cone of dimension dim.\n\nEpiPerSquare{T}(dim::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiNormSpectral","page":"Cones module","title":"Hypatia.Cones.EpiNormSpectral","text":"mutable struct EpiNormSpectral{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of real or complex matrix spectral norm (i.e. maximum singular value) for a matrix (stacked column-wise) of nrows rows and ncols columns with nrows ≤ ncols.\n\nEpiNormSpectral{T, R}(nrows::Int, ncols::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.MatrixEpiPerSquare","page":"Cones module","title":"Hypatia.Cones.MatrixEpiPerSquare","text":"mutable struct MatrixEpiPerSquare{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nMatrix epigraph of perspective function of real or complex matrix outer product for a matrix (stacked column-wise) of nrows rows and ncols columns with nrows ≤ ncols.\n\nMatrixEpiPerSquare{T, R}(nrows::Int, ncols::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.GeneralizedPower","page":"Cones module","title":"Hypatia.Cones.GeneralizedPower","text":"mutable struct GeneralizedPower{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nGeneralized power cone parametrized by powers α in the unit simplex and dimension d of the normed variables.\n\nGeneralizedPower{T}(α::Vector{T}, d::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.HypoPowerMean","page":"Cones module","title":"Hypatia.Cones.HypoPowerMean","text":"mutable struct HypoPowerMean{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nHypograph of weighted power mean cone parametrized by powers α in the unit simplex.\n\nHypoPowerMean{T}(α::Vector{T}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.HypoGeoMean","page":"Cones module","title":"Hypatia.Cones.HypoGeoMean","text":"mutable struct HypoGeoMean{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nHypograph of geometric mean cone of dimension dim.\n\nHypoGeoMean{T}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.HypoRootdetTri","page":"Cones module","title":"Hypatia.Cones.HypoRootdetTri","text":"mutable struct HypoRootdetTri{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nHypograph of real symmetric or complex Hermitian root-determinant cone of dimension dim in svec format.\n\nHypoRootdetTri{T, R}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.HypoPerLog","page":"Cones module","title":"Hypatia.Cones.HypoPerLog","text":"mutable struct HypoPerLog{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nHypograph of perspective function of sum-log cone of dimension dim.\n\nHypoPerLog{T}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.HypoPerLogdetTri","page":"Cones module","title":"Hypatia.Cones.HypoPerLogdetTri","text":"mutable struct HypoPerLogdetTri{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nHypograph of perspective function of real symmetric or complex Hermitian log-determinant cone of dimension dim in svec format.\n\nHypoPerLogdetTri{T, R}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiPerSepSpectral","page":"Cones module","title":"Hypatia.Cones.EpiPerSepSpectral","text":"mutable struct EpiPerSepSpectral{Q<:Hypatia.Cones.ConeOfSquares, T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of perspective function of a convex separable spectral function h over a cone of squares Q on a Jordan algebra with rank d.\n\nEpiPerSepSpectral{Q, T}(h::Hypatia.Cones.SepSpectralFun, d::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiRelEntropy","page":"Cones module","title":"Hypatia.Cones.EpiRelEntropy","text":"mutable struct EpiRelEntropy{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of vector relative entropy cone of dimension dim.\n\nEpiRelEntropy{T}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.EpiTrRelEntropyTri","page":"Cones module","title":"Hypatia.Cones.EpiTrRelEntropyTri","text":"mutable struct EpiTrRelEntropyTri{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nEpigraph of matrix relative entropy cone of dimension dim in svec format.\n\nEpiTrRelEntropyTri{T}(dim::Int, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.WSOSInterpNonnegative","page":"Cones module","title":"Hypatia.Cones.WSOSInterpNonnegative","text":"mutable struct WSOSInterpNonnegative{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.Cone{T<:Real}\n\nInterpolant-basis weighted sum-of-squares polynomial cone of dimension U, for real or real-valued complex polynomials , parametrized by vector of matrices Ps derived from interpolant basis and polynomial domain constraints.\n\nWSOSInterpNonnegative{T, R}(U::Int, Ps::Vector{Matrix{R}}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.WSOSInterpPosSemidefTri","page":"Cones module","title":"Hypatia.Cones.WSOSInterpPosSemidefTri","text":"mutable struct WSOSInterpPosSemidefTri{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nInterpolant-basis weighted sum-of-squares polynomial (of dimension U) positive semidefinite matrix (of side dimension R) cone, parametrized by vector of matrices Ps derived from interpolant basis and polynomial domain constraints.\n\nWSOSInterpPosSemidefTri{T}(R::Int, U::Int, Ps::Vector{Matrix{T}}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.WSOSInterpEpiNormEucl","page":"Cones module","title":"Hypatia.Cones.WSOSInterpEpiNormEucl","text":"mutable struct WSOSInterpEpiNormEucl{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nInterpolant-basis weighted sum-of-squares polynomial (of dimension U) epigraph of ℓ₂ norm (of dimension R) cone, parametrized by vector of matrices Ps derived from interpolant basis and polynomial domain constraints.\n\nWSOSInterpEpiNormEucl{T}(R::Int, U::Int, Ps::Vector{Matrix{T}}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.WSOSInterpEpiNormOne","page":"Cones module","title":"Hypatia.Cones.WSOSInterpEpiNormOne","text":"mutable struct WSOSInterpEpiNormOne{T<:Real} <: Hypatia.Cones.Cone{T<:Real}\n\nInterpolant-basis weighted sum-of-squares polynomial (of dimension U) epigraph of ℓ₁ norm (of dimension R) cone, parametrized by vector of matrices Ps derived from interpolant basis and polynomial domain constraints.\n\nWSOSInterpEpiNormOne{T}(R::Int, U::Int, Ps::Vector{Matrix{T}}, use_dual::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Helpers-for-PosSemidefTriSparse","page":"Cones module","title":"Helpers for PosSemidefTriSparse","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"PSDSparseImpl\nPSDSparseDense\nPSDSparseCholmod","category":"page"},{"location":"api/cones/#Hypatia.Cones.PSDSparseImpl","page":"Cones module","title":"Hypatia.Cones.PSDSparseImpl","text":"abstract type PSDSparseImpl\n\nAn implementation type for the sparse positive semidefinite cone PosSemidefTriSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.PSDSparseDense","page":"Cones module","title":"Hypatia.Cones.PSDSparseDense","text":"struct PSDSparseDense <: Hypatia.Cones.PSDSparseImpl\n\nDense Cholesky-based implementation for the sparse positive semidefinite cone PosSemidefTriSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.PSDSparseCholmod","page":"Cones module","title":"Hypatia.Cones.PSDSparseCholmod","text":"struct PSDSparseDense <: Hypatia.Cones.PSDSparseImpl\n\nDense Cholesky-based implementation for the sparse positive semidefinite cone PosSemidefTriSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#EpiPerSepSpectral-helpers","page":"Cones module","title":"EpiPerSepSpectral helpers","text":"","category":"section"},{"location":"api/cones/","page":"Cones module","title":"Cones module","text":"ConeOfSquares\nVectorCSqr\nMatrixCSqr\nvector_dim\nSepSpectralFun\nInvSSF\nNegLogSSF\nNegEntropySSF\nPower12SSF","category":"page"},{"location":"api/cones/#Hypatia.Cones.ConeOfSquares","page":"Cones module","title":"Hypatia.Cones.ConeOfSquares","text":"abstract type ConeOfSquares{T<:Real}\n\nA cone of squares on a Jordan algebra.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.VectorCSqr","page":"Cones module","title":"Hypatia.Cones.VectorCSqr","text":"struct VectorCSqr{T<:Real} <: Hypatia.Cones.ConeOfSquares{T<:Real}\n\nReal vector cone of squares.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.MatrixCSqr","page":"Cones module","title":"Hypatia.Cones.MatrixCSqr","text":"struct MatrixCSqr{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: Hypatia.Cones.ConeOfSquares{T<:Real}\n\nReal symmetric or complex Hermitian positive semidefinite cone of squares.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.vector_dim","page":"Cones module","title":"Hypatia.Cones.vector_dim","text":"vector_dim(_::Type{var\"#s68\"} where var\"#s68\"<:Hypatia.Cones.VectorCSqr, d::Int64) -> Int64\n\n\nThe rank of the vector cone of squares, equal to the vector length.\n\n\n\n\n\nvector_dim(_::Type{var\"#s67\"} where var\"#s67\"<:(Hypatia.Cones.MatrixCSqr{var\"#s66\", R} where var\"#s66\"<:Real), d::Int64) -> Int64\n\n\nThe rank of the matrix cone of squares, equal to the side dimension of the matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/cones/#Hypatia.Cones.SepSpectralFun","page":"Cones module","title":"Hypatia.Cones.SepSpectralFun","text":"abstract type SepSpectralFun\n\nA univariate convex function defined on positive reals.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.InvSSF","page":"Cones module","title":"Hypatia.Cones.InvSSF","text":"struct InvSSF <: Hypatia.Cones.SepSpectralFun\n\nThe inverse function x to x^-1.\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.NegLogSSF","page":"Cones module","title":"Hypatia.Cones.NegLogSSF","text":"struct NegLogSSF <: Hypatia.Cones.SepSpectralFun\n\nThe negative logarithm function x to - log(x).\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.NegEntropySSF","page":"Cones module","title":"Hypatia.Cones.NegEntropySSF","text":"struct NegEntropySSF <: Hypatia.Cones.SepSpectralFun\n\nThe negative entropy function x to x log(x).\n\n\n\n\n\n","category":"type"},{"location":"api/cones/#Hypatia.Cones.Power12SSF","page":"Cones module","title":"Hypatia.Cones.Power12SSF","text":"struct Power12SSF <: Hypatia.Cones.SepSpectralFun\n\nThe power function x to x^p parametrized by p in (1 2. Note for p = 2, it is more efficient to use EpiPerSquare on the scaled triangle.\n\n\n\n\n\n","category":"type"},{"location":"benchmarks/#Benchmarking-scripts","page":"Benchmarks","title":"Benchmarking scripts","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In the benchmarks folder, we have scripts for running performance benchmarks on instances derived from our examples. See Examples for descriptions of our examples, and see the examples folder for the instances, which are generated on-the-fly. The two types of benchmarks we run are:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"natural versus extended formulations, for a selection of examples; see natvsext,\nselected algorithmic options for the stepping procedures; see stepper.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We also provide scripts to analyze the raw results output from the run scripts. See the READMEs for simple instructions for running these scripts on your machines. Each run script typically takes several days to complete if running all examples, and the analysis scripts only take seconds.","category":"page"},{"location":"api/polyutils/#PolyUtils-module","page":"PolyUtils module","title":"PolyUtils module","text":"","category":"section"},{"location":"api/polyutils/","page":"PolyUtils module","title":"PolyUtils module","text":"CurrentModule = Hypatia.PolyUtils","category":"page"},{"location":"api/polyutils/","page":"PolyUtils module","title":"PolyUtils module","text":"PolyUtils","category":"page"},{"location":"api/polyutils/#Hypatia.PolyUtils","page":"PolyUtils module","title":"Hypatia.PolyUtils","text":"Utilities for constructing interpolant-basis polynomial sum-of-squares models.\n\n\n\n\n\n","category":"module"},{"location":"api/polyutils/#Real-polynomial-domains","page":"PolyUtils module","title":"Real polynomial domains","text":"","category":"section"},{"location":"api/polyutils/","page":"PolyUtils module","title":"PolyUtils module","text":"Domain\ndimension\ndegree\nsample\nweights\nEllipsoidDomain\nBoxDomain\nBallDomain\nFreeDomain","category":"page"},{"location":"api/polyutils/#Hypatia.PolyUtils.Domain","page":"PolyUtils module","title":"Hypatia.PolyUtils.Domain","text":"abstract type Domain{T<:Real}\n\nReal domains for polynomial constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/polyutils/#Hypatia.PolyUtils.dimension","page":"PolyUtils module","title":"Hypatia.PolyUtils.dimension","text":"dimension(dom)\n\n\nDimension of a domain.\n\n\n\n\n\n","category":"function"},{"location":"api/polyutils/#Hypatia.PolyUtils.degree","page":"PolyUtils module","title":"Hypatia.PolyUtils.degree","text":"degree(dom)\n\n\nDegree of a polynomial constraints defining a domain.\n\n\n\n\n\n","category":"function"},{"location":"api/polyutils/#Hypatia.PolyUtils.sample","page":"PolyUtils module","title":"Hypatia.PolyUtils.sample","text":"sample(dom, npts)\n\n\nSample npts points from the interior of the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/polyutils/#Hypatia.PolyUtils.weights","page":"PolyUtils module","title":"Hypatia.PolyUtils.weights","text":"weights(dom, pts)\n\n\nEvaluations of the polynomial domain constraints at the points.\n\n\n\n\n\n","category":"function"},{"location":"api/polyutils/#Hypatia.PolyUtils.EllipsoidDomain","page":"PolyUtils module","title":"Hypatia.PolyUtils.EllipsoidDomain","text":"mutable struct EllipsoidDomain{T<:Real} <: Hypatia.PolyUtils.Domain{T<:Real}\n\nHyperellipse (x-c) Q (x-c) leq 1 with center c::Vector{T} and symmetric positive definite scaling/rotation matrix Q::AbstractMatrix{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/polyutils/#Hypatia.PolyUtils.BoxDomain","page":"PolyUtils module","title":"Hypatia.PolyUtils.BoxDomain","text":"mutable struct BoxDomain{T<:Real} <: Hypatia.PolyUtils.Domain{T<:Real}\n\nHyperbox x  l u with lower bounds l::Vector{T} and upper bounds u::Vector{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/polyutils/#Hypatia.PolyUtils.BallDomain","page":"PolyUtils module","title":"Hypatia.PolyUtils.BallDomain","text":"mutable struct BallDomain{T<:Real} <: Hypatia.PolyUtils.Domain{T<:Real}\n\nEuclidean hyperball lVert (x-c) rVert_2 leq r with center c::Vector{T} and positive radius r::T.\n\n\n\n\n\n","category":"type"},{"location":"api/polyutils/#Hypatia.PolyUtils.FreeDomain","page":"PolyUtils module","title":"Hypatia.PolyUtils.FreeDomain","text":"mutable struct FreeDomain{T<:Real} <: Hypatia.PolyUtils.Domain{T<:Real}\n\nReal vectors x  ℝⁿ of dimension n::Int.\n\n\n\n\n\n","category":"type"},{"location":"api/polyutils/#Interpolation","page":"PolyUtils module","title":"Interpolation","text":"","category":"section"},{"location":"api/polyutils/","page":"PolyUtils module","title":"PolyUtils module","text":"interpolate","category":"page"},{"location":"api/polyutils/#Hypatia.PolyUtils.interpolate","page":"PolyUtils module","title":"Hypatia.PolyUtils.interpolate","text":"interpolate(dom, d; calc_V, get_quadr, sample, sample_factor)\n\n\nCompute interpolation data for a real weighted sum-of-squares conic constraint on a domain.\n\n\n\n\n\ninterpolate(R, halfdeg, n, gs, g_halfdegs; sample_factor, use_qr)\n\n\nCompute interpolation data for a complex weighted sum-of-squares conic constraint on a domain.\n\n\n\n\n\n","category":"function"},{"location":"modeling/#Conic-models","page":"Modeling","title":"Conic models","text":"","category":"section"},{"location":"modeling/#Conic-form","page":"Modeling","title":"Conic form","text":"","category":"section"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"Any convex optimization problem may be represented as a conic problem that minimizes a linear function over the intersection of an affine subspace with a Cartesian product of primitive proper cones (i.e. irreducible, closed, convex, pointed, and full-dimensional conic sets). An advantage of using conic form is that a conic problem, if well-posed, has a very simple and easily checkable certificate of optimality, primal infeasibility, or dual infeasibility.","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"Hypatia's primal conic form over variable x in mathbbR^n is:","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"beginaligned\nmin quad cx \n\nb - Ax = 0\n\nh - Gx in mathcalK\nendaligned","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"where mathcalK is a proper cone.","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"The corresponding conic dual form over variables y in mathbbR^p and z in mathbbR^q is:","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"beginaligned\nmax quad -by - hz \n\nc + Ay + Gz = 0\n\nz in mathcalK^*\nendaligned","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"where mathcalK^* is the dual cone of mathcalK.","category":"page"},{"location":"modeling/#Model-interface","page":"Modeling","title":"Model interface","text":"","category":"section"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"CurrentModule = Hypatia.Models","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"Hypatia's Models module specifies a Model type corresponding to the primal conic form above:","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"mathcalK is a vector of Hypatia cones,\nc in mathbbR^n, b in mathbbR^p, h in mathbbR^q are vectors,\nA in mathbbR^p times n and G in mathbbR^q times n are linear operators.","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"An objective offset can be specified using the keyword arg obj_offset (the default is 0). See Models module.","category":"page"},{"location":"modeling/#Polynomial-utilities","page":"Modeling","title":"Polynomial utilities","text":"","category":"section"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"CurrentModule = Hypatia.PolyUtils","category":"page"},{"location":"modeling/","page":"Modeling","title":"Modeling","text":"The PolyUtils module provides tools for setting up polynomial interpolations for sum-of-squares models; see PolyUtils module.","category":"page"},{"location":"cones/#Cone-interface-and-predefined-cones","page":"Cones","title":"Cone interface and predefined cones","text":"","category":"section"},{"location":"cones/","page":"Cones","title":"Cones","text":"CurrentModule = Hypatia.Cones","category":"page"},{"location":"cones/#Generic-cone-interface","page":"Cones","title":"Generic cone interface","text":"","category":"section"},{"location":"cones/","page":"Cones","title":"Cones","text":"Hypatia's Cones module specifies a generic cone interface that allows defining new proper cones as subtypes of Cone. This requires implementing cone oracles as methods for the new cone type; see Cone oracles. The required oracles are:","category":"page"},{"location":"cones/","page":"Cones","title":"Cones","text":"an initial interior point inside the cone; see set_initial_point!,\na feasibility test, which checks whether a given point is in the interior of the cone; see is_feas,\ngradient and Hessian evaluations for a logarithmically homogeneous self-concordant barrier (LHSCB) function for the cone; see grad and hess.","category":"page"},{"location":"cones/","page":"Cones","title":"Cones","text":"Additional optional oracles can be specified to improve speed and numerical performance. Defining a new cone automatically defines its dual cone (through the use_dual option) also. See Hypatia's predefined cones in the cones folder for examples of how to implement a new cone type and efficient oracles. The implementations of the HypoPowerMean cone (which uses a primal LHSCB) and the WSOSInterpNonnegative cone (which uses a dual LHSCB) are fairly typical.","category":"page"},{"location":"cones/#Predefined-cones","page":"Cones","title":"Predefined cones","text":"","category":"section"},{"location":"cones/","page":"Cones","title":"Cones","text":"Hypatia predefines many proper cones that are practically useful; see Predefined cone types. These cones are used in Hypatia's Examples and native instances. These cones are also wrapped as MathOptInterface.AbstractVectorSet types and exported from Hypatia; see MathOptInterface cones.","category":"page"},{"location":"api/hypatia/#Hypatia-module","page":"Hypatia module","title":"Hypatia module","text":"","category":"section"},{"location":"api/hypatia/","page":"Hypatia module","title":"Hypatia module","text":"CurrentModule = Hypatia","category":"page"},{"location":"api/hypatia/","page":"Hypatia module","title":"Hypatia module","text":"Hypatia","category":"page"},{"location":"api/hypatia/#Hypatia.Hypatia","page":"Hypatia module","title":"Hypatia.Hypatia","text":"A Julia package for generic conic optimization with interior point algorithms.\n\n\n\n\n\n","category":"module"},{"location":"api/hypatia/#MathOptInterface-optimizer","page":"Hypatia module","title":"MathOptInterface optimizer","text":"","category":"section"},{"location":"api/hypatia/","page":"Hypatia module","title":"Hypatia module","text":"Optimizer","category":"page"},{"location":"api/hypatia/#Hypatia.Optimizer","page":"Hypatia module","title":"Hypatia.Optimizer","text":"mutable struct Optimizer{T<:Real} <: MathOptInterface.AbstractOptimizer\n\nA MathOptInterface optimizer type for Hypatia.\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#MathOptInterface-cones","page":"Hypatia module","title":"MathOptInterface cones","text":"","category":"section"},{"location":"api/hypatia/","page":"Hypatia module","title":"Hypatia module","text":"NonnegativeCone\nPosSemidefTriCone\nDoublyNonnegativeTriCone\nPosSemidefTriSparseCone\nLinMatrixIneqCone\nEpiNormInfCone\nEpiNormEuclCone\nEpiPerSquareCone\nEpiNormSpectralCone\nMatrixEpiPerSquareCone\nGeneralizedPowerCone\nHypoPowerMeanCone\nHypoGeoMeanCone\nHypoRootdetTriCone\nHypoPerLogCone\nHypoPerLogdetTriCone\nEpiPerSepSpectralCone\nEpiRelEntropyCone\nEpiTrRelEntropyTriCone\nWSOSInterpNonnegativeCone\nWSOSInterpPosSemidefTriCone\nWSOSInterpEpiNormEuclCone\nWSOSInterpEpiNormOneCone","category":"page"},{"location":"api/hypatia/#Hypatia.NonnegativeCone","page":"Hypatia module","title":"Hypatia.NonnegativeCone","text":"struct NonnegativeCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.Nonnegative.\n\ndim::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.PosSemidefTriCone","page":"Hypatia module","title":"Hypatia.PosSemidefTriCone","text":"struct PosSemidefTriCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.PosSemidefTri.\n\ndim::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.DoublyNonnegativeTriCone","page":"Hypatia module","title":"Hypatia.DoublyNonnegativeTriCone","text":"struct DoublyNonnegativeTriCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.DoublyNonnegativeTri.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.PosSemidefTriSparseCone","page":"Hypatia module","title":"Hypatia.PosSemidefTriSparseCone","text":"struct PosSemidefTriSparseCone{I<:Hypatia.Cones.PSDSparseImpl, T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.PosSemidefTriSparse.\n\nside::Int64\nrow_idxs::Vector{Int64}\ncol_idxs::Vector{Int64}\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.LinMatrixIneqCone","page":"Hypatia module","title":"Hypatia.LinMatrixIneqCone","text":"struct LinMatrixIneqCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.LinMatrixIneq.\n\nAs::Vector{T} where T\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiNormInfCone","page":"Hypatia module","title":"Hypatia.EpiNormInfCone","text":"struct EpiNormInfCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiNormInf.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiNormEuclCone","page":"Hypatia module","title":"Hypatia.EpiNormEuclCone","text":"struct EpiNormEuclCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiNormEucl.\n\ndim::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiPerSquareCone","page":"Hypatia module","title":"Hypatia.EpiPerSquareCone","text":"struct EpiPerSquareCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiPerSquare.\n\ndim::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiNormSpectralCone","page":"Hypatia module","title":"Hypatia.EpiNormSpectralCone","text":"struct EpiNormSpectralCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiNormSpectral.\n\nn::Int64\nm::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.MatrixEpiPerSquareCone","page":"Hypatia module","title":"Hypatia.MatrixEpiPerSquareCone","text":"struct MatrixEpiPerSquareCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.MatrixEpiPerSquare.\n\nn::Int64\nm::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.GeneralizedPowerCone","page":"Hypatia module","title":"Hypatia.GeneralizedPowerCone","text":"struct GeneralizedPowerCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.GeneralizedPower.\n\nα::Vector{T} where T<:Real\nn::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.HypoPowerMeanCone","page":"Hypatia module","title":"Hypatia.HypoPowerMeanCone","text":"struct HypoPowerMeanCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.HypoPowerMean.\n\nα::Vector{T} where T<:Real\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.HypoGeoMeanCone","page":"Hypatia module","title":"Hypatia.HypoGeoMeanCone","text":"struct HypoGeoMeanCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.HypoGeoMean.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.HypoRootdetTriCone","page":"Hypatia module","title":"Hypatia.HypoRootdetTriCone","text":"struct HypoRootdetTriCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.HypoRootdetTri.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.HypoPerLogCone","page":"Hypatia module","title":"Hypatia.HypoPerLogCone","text":"struct HypoPerLogCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.HypoPerLog.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.HypoPerLogdetTriCone","page":"Hypatia module","title":"Hypatia.HypoPerLogdetTriCone","text":"struct HypoPerLogdetTriCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.HypoPerLogdetTri.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiPerSepSpectralCone","page":"Hypatia module","title":"Hypatia.EpiPerSepSpectralCone","text":"struct EpiPerSepSpectralCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiPerSepSpectral.\n\nh::Hypatia.Cones.SepSpectralFun\nQ::Type{var\"#s474\"} where {T<:Real, var\"#s474\"<:Hypatia.Cones.ConeOfSquares{T}}\nd::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiRelEntropyCone","page":"Hypatia module","title":"Hypatia.EpiRelEntropyCone","text":"struct EpiRelEntropyCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiRelEntropy.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.EpiTrRelEntropyTriCone","page":"Hypatia module","title":"Hypatia.EpiTrRelEntropyTriCone","text":"struct EpiTrRelEntropyTriCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.EpiTrRelEntropyTri.\n\ndim::Int64\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.WSOSInterpNonnegativeCone","page":"Hypatia module","title":"Hypatia.WSOSInterpNonnegativeCone","text":"struct WSOSInterpNonnegativeCone{T<:Real, R<:Union{Complex{T<:Real}, T<:Real}} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.WSOSInterpNonnegative.\n\nU::Int64\nPs::Array{Matrix{R}, 1} where {T<:Real, R<:Union{Complex{T}, T}}\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.WSOSInterpPosSemidefTriCone","page":"Hypatia module","title":"Hypatia.WSOSInterpPosSemidefTriCone","text":"struct WSOSInterpPosSemidefTriCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.WSOSInterpPosSemidefTri.\n\nR::Int64\nU::Int64\nPs::Array{Matrix{T}, 1} where T<:Real\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.WSOSInterpEpiNormEuclCone","page":"Hypatia module","title":"Hypatia.WSOSInterpEpiNormEuclCone","text":"struct WSOSInterpEpiNormEuclCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.WSOSInterpEpiNormEucl.\n\nR::Int64\nU::Int64\nPs::Array{Matrix{T}, 1} where T<:Real\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/hypatia/#Hypatia.WSOSInterpEpiNormOneCone","page":"Hypatia module","title":"Hypatia.WSOSInterpEpiNormOneCone","text":"struct WSOSInterpEpiNormOneCone{T<:Real} <: MathOptInterface.AbstractVectorSet\n\nSee Cones.WSOSInterpEpiNormOne.\n\nR::Int64\nU::Int64\nPs::Array{Matrix{T}, 1} where T<:Real\nuse_dual::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solvers-module","page":"Solvers module","title":"Solvers module","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers module","title":"Solvers module","text":"See the Solving conic models section.","category":"page"},{"location":"api/solvers/","page":"Solvers module","title":"Solvers module","text":"CurrentModule = Hypatia.Solvers","category":"page"},{"location":"api/solvers/","page":"Solvers module","title":"Solvers module","text":"Solvers\nSolver","category":"page"},{"location":"api/solvers/#Hypatia.Solvers","page":"Solvers module","title":"Hypatia.Solvers","text":"Interior point algorithms for conic models.\n\n\n\n\n\n","category":"module"},{"location":"api/solvers/#Hypatia.Solvers.Solver","page":"Solvers module","title":"Hypatia.Solvers.Solver","text":"mutable struct Solver{T<:Real}\n\nHypatia's interior point solver type. See source for options and defaults.\n\n\n\n\n\n","category":"type"},{"location":"solving/#Solving-conic-models","page":"Solving","title":"Solving conic models","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"Hypatia can be accessed through a low-level native Julia interface or through open-source modeling tools such as JuMP and Convex.jl. The native interface is more expressive, allowing Hypatia to solve conic models expressed with generic real floating point types and structured matrices or linear operators, for example. However, it is typically sufficient and more convenient to use JuMP.","category":"page"},{"location":"solving/#Native-interface","page":"Solving","title":"Native interface","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"CurrentModule = Hypatia.Solvers","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"Hypatia's Solvers module provides a Solver type with low-level functions for solving models and querying solve information and conic certificates; see Solvers module.","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"Below is a simple example of a spectral norm optimization problem:","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"using LinearAlgebra\nimport Hypatia\nimport Hypatia.Cones\nimport Hypatia.Solvers\n\nT = BigFloat\n(Xn, Xm) = (3, 4)\ndim = Xn * Xm\nc = vcat(one(T), zeros(T, dim))\nA = hcat(zeros(T, dim, 1), Matrix{T}(I, dim, dim))\nb = rand(T, dim)\nG = -one(T) * I\nh = vcat(zero(T), rand(T, dim))\ncones = [Cones.EpiNormSpectral{T, T}(Xn, Xm),]\nmodel = Hypatia.Models.Model{T}(c, A, b, G, h, cones);","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"Now we call optimize and query the solution:","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"julia> solver = Solvers.Solver{T}(verbose = true);\n\njulia> Solvers.load(solver, model);\n\njulia> Solvers.solve(solver);\n\n iter        p_obj        d_obj |  abs_gap    x_feas    z_feas |      tau       kap        mu |  dir_res  step     alpha\n    0   2.0000e+00   0.0000e+00 | 4.00e+00  5.00e-01  6.14e-01 | 1.00e+00  1.00e+00  1.00e+00 |\n    1   2.5147e+00   2.2824e+00 | 1.07e+00  2.24e-01  2.74e-01 | 6.71e-01  7.44e-01  3.14e-01 | 3.45e-77  co-a  7.00e-01\n    2   3.0958e+00   3.0966e+00 | 3.39e-01  7.40e-02  9.08e-02 | 6.08e-01  2.70e-01  1.01e-01 | 1.73e-77  co-a  7.00e-01\n...\n   33   3.2962e+00   3.2962e+00 | 1.33e-30  1.86e-30  2.29e-30 | 2.21e-01  1.88e-30  3.50e-31 | 4.85e-50  co-a  5.00e-01\n   34   3.2962e+00   3.2962e+00 | 2.29e-31  2.77e-31  3.40e-31 | 2.23e-01  1.56e-31  5.28e-32 | 2.70e-48  co-a  8.50e-01\n   35   3.2962e+00   3.2962e+00 | 7.32e-32  1.21e-31  1.49e-31 | 2.04e-01  1.15e-31  1.93e-32 | 2.52e-49  co-a  6.00e-01\noptimal solution found; terminating\n\nstatus is Optimal after 35 iterations and 1.417 seconds\n\njulia> Solvers.get_status(solver)\nOptimal::Status = 3\n\njulia> Solvers.get_primal_obj(solver)\n3.296219213377718379486912616497183695150874915748434424139285907044225666610375\n\njulia> Solvers.get_dual_obj(solver)\n3.29621921337771837948691261649702242580041815859477664034990154727149325280482\n\njulia> Solvers.get_x(solver)\n13-element Vector{BigFloat}:\n 3.296219213377718379486912616497183695150874915748434424139285907044225666610375\n 0.2014951884389319019635492500560556305705409904059068283971229702024509946542355\n 0.2974304558864173403751380894865665103907350340298129119333915978313596204101965\n...\n 0.5076818262444516526146124557277599761994226912376378984924714206880970861448005\n 0.4719189060586783692091058031965586401783925037880741775651825386863356120491953\n 0.6377366379371803537625028513405673487028387050401566067448589228065218202592247","category":"page"},{"location":"solving/#MathOptInterface-and-JuMP","page":"Solving","title":"MathOptInterface and JuMP","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"CurrentModule = Hypatia","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"JuMP is generally more user-friendly than Hypatia's native interface, though it may make sense to try the more-expressive native interface for large dense or structured models. Hypatia exports MathOptInterface wrappers for Hypatia's solver (see Optimizer) and predefined cones (see MathOptInterface cones).","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"Below is a simple example from D-optimal experiment design:","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"using LinearAlgebra\nusing JuMP\nusing Hypatia\n\nopt = Hypatia.Optimizer(verbose = false)\nmodel = Model(() -> opt)\n@variable(model, x[1:3] >= 0)\n@constraint(model, sum(x) == 5)\n@variable(model, hypo)\n@objective(model, Max, hypo)\nV = rand(2, 3)\nQ = V * diagm(x) * V'\naff = vcat(hypo, [Q[i, j] for i in 1:2 for j in 1:i]...)\n@constraint(model, aff in MOI.RootDetConeTriangle(2))","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"The model is now:","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"julia> model\nA JuMP Model\nMaximization problem with:\nVariables: 4\nObjective function type: VariableRef\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`Vector{AffExpr}`-in-`MathOptInterface.RootDetConeTriangle`: 1 constraint\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Hypatia\nNames registered in the model: hypo, x","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"Now we call optimize and query the solution:","category":"page"},{"location":"solving/","page":"Solving","title":"Solving","text":"julia> optimize!(model)\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1\n\njulia> objective_value(model)\n1.4303650845824805\n\njulia> value.(x)\n3-element Vector{Float64}:\n 2.499999987496876\n 2.499999992300735\n 2.0202389761081463e-8","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"See the Hypatia examples folder for example models and corresponding test/benchmark instances. Most examples have options for instance sizes/characteristics and formulation variants. See the example files for more information and references. Most example models use JuMP, and some use Hypatia's native interface. New examples are welcomed and should be implemented similarly to the existing examples and linked from this page.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CBLIB. Run a given CBLIB instance from the Conic Benchmark Library.\nCentral polynomial matrix. Minimize a spectral function of a gram matrix of a polynomial.\nClassical-quantum capacity. Compute the capacity of a classical-to-quantum channel.\nCondition number. Minimize the condition number of a matrix pencil subject to a linear matrix inequality.\nContraction analysis. Find a contraction metric that guarantees global stability of a dynamical system.\nConvexity parameter. Find the strong convexity parameter of a polynomial function over a domain.\nCovariance estimation. Estimate a covariance matrix that satisfies some given prior information and minimizes a given convex spectral function.\nDensity estimation. Find a valid polynomial density function maximizing the likelihood of a set of observations.\nDiscrete maximum likelihood. Maximize likelihood of observations at discrete points, subject to probability vector not being too far from a uniform prior.\nD-optimal design. Solve a D-optimal experiment design problem, i.e. maximize the determinant of the information matrix subject to side constraints.\nEntanglement-assisted capacity. Compute the entanglement-assisted classical capacity of a quantum channel.\nExperiment design. Solve a general experiment design problem that minimizes a given convex spectral function of the information matrix subject to side constraints.\nLinear program. Solve a simple linear program.\nLotka-Volterra. Find an optimal controller for a Lotka-Volterra model of population dynamics.\nLyapunov stability. Minimize an upper bound on the root mean square gain of a dynamical system.\nMatrix completion. Complete a rectangular matrix by minimizing the nuclear norm and constraining the missing entries.\nMatrix quadratic. Find a rectangular matrix that minimizes a linear function and satisfies a constraint on the outer product of the matrix.\nMatrix regression. Solve a multiple-output (or matrix) regression problem with regularization terms (such as ell_1, ell_2, or nuclear norm).\nMaximum volume hypercube. Find a maximum volume hypercube (with edges parallel to the axes) inside a given polyhedron or ellipsoid.\nNearest correlation matrix. Compute the nearest correlation matrix in the quantum relative entropy sense.\nNearest polynomial matrix. Given a symmetric matrix of polynomials H, find a polynomial matrix Q that minimizes the sum of the integrals of its elements over the unit box and guarantees Q - H is pointwise PSD on the unit box.\nNearest PSD matrix. Find a sparse PSD matrix or a PSD-completable matrix (with a given sparsity pattern) with constant trace that maximizes a linear function.\nNonparametric distribution estimation. Given a random variable taking values in a finite set, compute the distribution minimizing a given convex spectral function over all distributions satisfying some prior information.\nNorm cone polynomial. Given a vector of polynomials, check a sufficient condition for pointwise membership in the epigraph of the ell_1 or ell_2 norm.\nPolynomial envelope. Find a polynomial that closely approximates, over the unit box, the lower envelope of a given list of polynomials.\nPolynomial minimization. Compute a lower bound for a given polynomial over a given semialgebraic set.\nPolynomial norm. Find a polynomial that, over the unit box, has minimal integral and belongs pointwise to the epigraph of the ell_1 or ell_2 norm of other given polynomials.\nPortfolio. Maximize the expected returns of a stock portfolio and satisfy various risk constraints.\nRegion of attraction. Find the region of attraction of a polynomial control system.\nRelative entropy of entanglement. Compute a lower bound on relative entropy of entanglement with a positive partial transpose relaxation.\nRobust geometric programming. Bound the worst-case optimal value of an uncertain signomial function with a given coefficient uncertainty set.\nSemidefinite polynomial matrix. Check a sufficient condition for global convexity of a given polynomial.\nShape constrained regression. Given a dataset, fit a polynomial function that satisfies shape constraints such as monotonicity or convexity over a domain.\nSignomial minimization. Compute a global lower bound for a given signomial function.\nSparse LMI. Optimize over a simple linear matrix inequality with sparse data.\nSparse principal components. Solve a convex relaxation of the problem of approximating a symmetric matrix by a rank-one matrix with a cardinality-constrained eigenvector.\nStability number. Given a graph, solve for a particular strengthening of the theta function towards the stability number.","category":"page"},{"location":"#Hypatia","page":"Home","title":"Hypatia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hypatia is a highly-customizable interior point solver for generic conic optimization problems, written in Julia. It is licensed under the MIT License; see LICENSE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the README for a quick-start introduction. For more information about Hypatia's algorithms and cones, please see our working paper and cones reference.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use Hypatia, install Julia, then at the Julia REPL, type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"Hypatia\")\n\njulia> using Hypatia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hypatia is an experimental solver and a work in progress, and may not run with older releases of Julia. Default options/parameters are not well-tuned, so we encourage you to experiment with these.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hypatia can be accessed through a low-level native Julia interface or through open-source modeling tools such as JuMP and Convex.jl. The native interface is more expressive, allowing Hypatia to solve conic models expressed with generic real floating point types and structured matrices or linear operators, for example. However, it is typically sufficient and more convenient to use JuMP.","category":"page"},{"location":"api/models/#Models-module","page":"Models module","title":"Models module","text":"","category":"section"},{"location":"api/models/","page":"Models module","title":"Models module","text":"See the Conic models section.","category":"page"},{"location":"api/models/","page":"Models module","title":"Models module","text":"CurrentModule = Hypatia.Models","category":"page"},{"location":"api/models/","page":"Models module","title":"Models module","text":"Models\nModel","category":"page"},{"location":"api/models/#Hypatia.Models","page":"Models module","title":"Hypatia.Models","text":"Conic models and utilities.\n\n\n\n\n\n","category":"module"},{"location":"api/models/#Hypatia.Models.Model","page":"Models module","title":"Hypatia.Models.Model","text":"mutable struct Model{T<:Real}\n\nConic model corresponding to Hypatia's primal general conic form.\n\n\n\n\n\n","category":"type"}]
}
